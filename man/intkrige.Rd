% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/intKrigeDriver.R
\name{intkrige}
\alias{intkrige}
\title{Algorithmic implementation of interval valued kriging.}
\usage{
intkrige(locations, measurements, newdata, modelC, modelR,
  modelCR = NULL, eta = 0.75, A = c(1, 1, 0), trend = NULL,
  thresh = 100, tolq = 0.001, maxq = 100, tolp = 0.001,
  maxp = 100, r = 1, useR = TRUE, geographic = FALSE,
  fast = FALSE, weights = FALSE, cores = 1)
}
\arguments{
\item{locations}{A two column matrix containing the x/y
(longitude/latitude) coordinates of the input data.}

\item{measurements}{A two column matrix containing the center/radius
measurements corresponding to the input locations.}

\item{newdata}{A two column matrix containing the x/y
(longitude/latitude) coordinates of the prediction locations.}

\item{modelC}{variogram model of class vgm (see \link[gstat]{vgm})
for the centers of the intervals}

\item{modelR}{variogram model of class vgm for radii}

\item{modelCR}{If NULL, assume no interaction between center and radius.
When specified, represents vgm model for the center/radius interaction.}

\item{eta}{growth/shrink parameter for penalty term.
For simple kriging: eta > 1. For ordinary kriging eta < 1.}

\item{A}{vector of length three representing the weights
of the generalized L2 distance: the vector of three contains the weights for
the center, radius, and center/radius respectively.
A = c(1, 1, 0) assumes the regular L2 distance calculation for intervals.}

\item{trend}{If null, use ordinary kriging. When specified, represents the
known mean of the stationary process, an indication to use simple kriging.}

\item{thresh}{Let n = length(locations). When abs(lam_i) < 1/(n*thresh),
this lambda value is set to 0.}

\item{tolq}{For a set penalty term, convergence is satisfied if
max(abs(lamUp-lam)) < tolq.}

\item{maxq}{For a set penalty term, max number of iterations
allowed for convergence.}

\item{tolp}{When abs(sum(abs(lam)) - 1) < tolp, consider the
constraints satisfied.}

\item{maxp}{Maximum number of allowed iterations to satisfy
equation constraints.}

\item{r}{The starting value of the penalty term. Must be relatively large to
ensure that the initial solution stays within the feasible region.}

\item{useR}{If TRUE, use the R version of the algorithm.
If FALSE, use the rcppArmadillo version.}

\item{geographic}{If TRUE, use great circle distance calcuations.
If FALSE, use euclidean distances.}

\item{fast}{(Simple kriging only). If TRUE, allows lambdas to converge to 0
and subsets matrices accordingly. When FALSE, runs simple kriging using a
barrier penalty at 0. Fast = TRUE is orders of maginitude faster than the
full implementation. However, it is not recommended when input measurements
are sparse as it is known to have convergence issues in these cases.}

\item{weights}{If TRUE, return the vector kriging weights for each prediction.
If false, simply return the predicted output.}

\item{cores}{An integer (for parallel computing): specify the number
of cores that will be devoted to the computation.
Note that the argument 'all' will
use all available cores minus one.
Parallel processing is only relevant if you are predicting
for more than one location.
Note there is no parallel option when useR = FALSE.}
}
\value{
A matrix with three columns containing the predicted centers
and radii for the locations of interest (columns 1 and 2) as well as the
prediction variance according to the distance matrix determined by A.
}
\description{
Function to implement the interval valued extension of ordinary and
simple kriging. Includes all necessary input checks and error handling.
Essentially acts as a switch function between the R and c++ versions
of the algorithm.
}
\examples{
library(gstat)
data(samples)
data(newData)
locs1 <- coordinates(samples)
values <- as.matrix(data.frame(truthC = samples$truthC,
truthR = samples$truthR))
locs2 <- coordinates(newData)

modelC = vgm(1, "Exp", 1/4)
modelR = vgm(1, "Exp", 1/5)

# Simple kriging test
test.simple <- intkrige(locs1, values, locs2,
                          modelC, modelR, modelCR = NULL, eta = .75,
                          A = c(1, 1, 0), trend = 0, thresh = 100,
                          tolq = .001, maxp = 100, tolp = .001,
                          maxq = 100, r = 100)

# Ordinary kriging test (takes much longer to run, hence the subsetting)
test.ordinary <- intkrige(locs1, values, locs2,
                          modelC, modelR, modelCR = NULL, eta = 0.75,
                          A = c(1, 1, 0), trend = NULL, thresh = 100,
                          tolq = .001, maxp = 100, tolp = .001,
                          maxq = 100, r = 100)


newData$PredictC <- test.simple[, 1]
newData$PredictR <- test.simple[, 2]

newData$PredictC2 <- test.ordinary[, 1]
newData$PredictR2 <- test.ordinary[, 2]

l2Dist.simple <- mean(sqrt((newData$PredictC - newData$truthC)^2 +
                   (newData$PredictR - newData$truthR)^2))

l2Dist.ordinary <- mean(sqrt((newData$PredictC2 - newData$truthC)^2 +
                   (newData$PredictR2 - newData$truthR)^2))
l2Dist.simple
l2Dist.ordinary

}
